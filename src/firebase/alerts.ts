// firebase/alerts.ts
import { 
  collection, 
  addDoc, 
  query, 
  where, 
  orderBy, 
  limit, 
  getDocs, 
  updateDoc, 
  doc, 
  onSnapshot,
  Timestamp,
  serverTimestamp,
  writeBatch
} from 'firebase/firestore';
import { db } from './firebase-config';
import { addNotificationWithDuplicateCheck } from './notifications';

export interface EscalationEntry {
  timestamp: string;
  escalatedBy: string;
  reason: string;
  notifiedPersons: string[];
  actionsTaken: string[];
  followUpRequired: boolean;
}

export interface CriticalAlert {
  id?: string;
  patientId: string;
  patientName: string;
  alertType?: 'vitals' | 'auto-escalation' | 'medication' | 'emergency' | 'other';
  triage?: 'Critical' | 'High' | 'Medium' | 'Low';
  message: string;
  abnormalVitals?: string[];
  vitals?: {
    heartRate?: number;
    systolicBP?: number;
    diastolicBP?: number;
    respiratoryRate?: number;
    oxygenSaturation?: number;
    temperature?: number;
  };
  criticalityScore?: number;
  acknowledged?: boolean;
  acknowledgedBy?: string;
  acknowledgedAt?: string;
  timestamp?: Timestamp;
  updatedAt?: Timestamp;
  userId?: string;
  businessId: string;
  severity?: 'critical' | 'high' | 'medium' | 'low';
  resolved?: boolean;
  resolvedAt?: Timestamp;
  resolvedBy?: string;
  ward?: string;
  hospital?: string;
  diagnosis?: string;
  doctorAssigned?: string;
  comorbidities?: string;
  allergies?: string;
  height?: string;
  weight?: string;
  patientAge?: number;
  bloodPressure?: string;
  heartRate?: number;
  temperature?: number;
  oxygenSaturation?: number;
  autoGenerated?: boolean;
  escalationHistory?: EscalationEntry[];
  createdBy?: string;
  priority?: 'low' | 'medium' | 'high' | 'critical';
  actionRequired?: string;
  relatedNotificationId?: string;
}

// Enhanced critical alert creation with notification integration
export const createCriticalAlert = async (alertData: Omit<CriticalAlert, 'id' | 'timestamp' | 'updatedAt'>): Promise<string> => {
  try {
    // Create the alert
    const alertsRef = collection(db, 'critical_alerts');
    const docRef = await addDoc(alertsRef, {
      ...alertData,
      timestamp: serverTimestamp(),
      updatedAt: serverTimestamp(),
      acknowledged: alertData.acknowledged ?? false,
      resolved: alertData.resolved ?? false,
      autoGenerated: alertData.autoGenerated ?? true,
      priority: alertData.severity || 'medium'
    });

    console.log('‚úÖ Critical alert created:', docRef.id);

    // Create corresponding notification if userId is provided
    if (alertData.userId) {
      try {
        const notificationId = await addNotificationWithDuplicateCheck({
          userId: alertData.userId,
          title: `üö® Critical Alert - ${alertData.patientName}`,
          body: alertData.message
        }, {
          metaType: 'critical-alert',
          role: 'healthcare-provider',
          priority: alertData.severity === 'critical' ? 'critical' : 'high',
          data: {
            alertId: docRef.id,
            patientId: alertData.patientId,
            patientName: alertData.patientName,
            alertType: alertData.alertType
          }
        });

        // Update alert with notification reference
        if (notificationId) {
          await updateDoc(docRef, { relatedNotificationId: notificationId });
        }
      } catch (notificationError) {
        console.error('Failed to create notification for alert:', notificationError);
        // Don't fail the alert creation if notification fails
      }
    }

    return docRef.id;
  } catch (error) {
    console.error('‚ùå Error creating critical alert:', error);
    throw error;
  }
};

// Enhanced vitals alert creation
export const createVitalsAlert = async (
  patientId: string,
  patientName: string,
  userId: string,
  businessId: string,
  vitals: any,
  abnormalVitals: string[],
  triageStatus: 'Critical' | 'High' | 'Medium' | 'Low',
  criticalityScore: number
): Promise<string> => {
  const alertData: Omit<CriticalAlert, 'id' | 'timestamp' | 'updatedAt'> = {
    patientId,
    patientName,
    alertType: 'vitals',
    triage: triageStatus,
    message: `Critical vitals detected for ${patientName}. Abnormal vitals: ${abnormalVitals.join(', ')}`,
    abnormalVitals,
    vitals,
    criticalityScore,
    acknowledged: false,
    userId,
    businessId,
    severity: triageStatus === 'Critical' ? 'critical' : triageStatus === 'High' ? 'high' : 'medium',
    resolved: false,
    autoGenerated: true,
    actionRequired: `Immediate assessment required for ${abnormalVitals.join(', ')}`
  };
  
  return await createCriticalAlert(alertData);
};

// Get critical alerts with enhanced filtering
export const getCriticalAlerts = async (
  businessId: string, 
  options?: {
    resolved?: boolean;
    severity?: string;
    limitCount?: number;
    patientId?: string;
  }
): Promise<CriticalAlert[]> => {
  try {
    const alertsRef = collection(db, 'critical_alerts');
    let q = query(
      alertsRef,
      where('businessId', '==', businessId)
    );

    // Add filters
    if (options?.resolved !== undefined) {
      q = query(q, where('resolved', '==', options.resolved));
    }
    if (options?.severity) {
      q = query(q, where('severity', '==', options.severity));
    }
    if (options?.patientId) {
      q = query(q, where('patientId', '==', options.patientId));
    }

    // Add ordering and limit
    q = query(q, orderBy('timestamp', 'desc'));
    if (options?.limitCount) {
      q = query(q, limit(options.limitCount));
    }

    const querySnapshot = await getDocs(q);
    const alerts: CriticalAlert[] = [];
    
    querySnapshot.forEach((doc) => {
      alerts.push({ id: doc.id, ...doc.data() as CriticalAlert });
    });
    
    return alerts;
  } catch (error) {
    console.error('‚ùå Error fetching critical alerts:', error);
    throw error;
  }
};

// Enhanced unacknowledged alerts with priority sorting
export const getUnacknowledgedAlerts = async (
  userId: string, 
  businessId: string
): Promise<CriticalAlert[]> => {
  try {
    const alertsRef = collection(db, 'critical_alerts');
    const q = query(
      alertsRef,
      where('userId', '==', userId),
      where('businessId', '==', businessId),
      where('acknowledged', '==', false),
      where('resolved', '==', false),
      orderBy('timestamp', 'desc')
    );
    
    const querySnapshot = await getDocs(q);
    const alerts: CriticalAlert[] = [];
    
    querySnapshot.forEach((doc) => {
      alerts.push({ id: doc.id, ...doc.data() } as CriticalAlert);
    });
    
    // Sort by priority: critical, high, medium, low
    const priorityOrder = { 'critical': 0, 'high': 1, 'medium': 2, 'low': 3 };
    alerts.sort((a, b) => {
      const aPriority = priorityOrder[a.severity as keyof typeof priorityOrder] ?? 3;
      const bPriority = priorityOrder[b.severity as keyof typeof priorityOrder] ?? 3;
      return aPriority - bPriority;
    });
    
    return alerts;
  } catch (error) {
    console.error('‚ùå Error fetching unacknowledged alerts:', error);
    throw error;
  }
};

// Enhanced acknowledge alert with notification update
export const acknowledgeAlert = async (
  alertId: string,
  acknowledgedBy: string
): Promise<void> => {
  try {
    const alertRef = doc(db, 'critical_alerts', alertId);
    await updateDoc(alertRef, {
      acknowledged: true,
      acknowledgedBy,
      acknowledgedAt: new Date().toISOString(),
      updatedAt: serverTimestamp()
    });
    
    console.log('‚úÖ Alert acknowledged:', alertId);
  } catch (error) {
    console.error('‚ùå Error acknowledging alert:', error);
    throw error;
  }
};

// Bulk acknowledge alerts
export const acknowledgeMultipleAlerts = async (
  alertIds: string[],
  acknowledgedBy: string
): Promise<void> => {
  try {
    const batch = writeBatch(db);
    
    alertIds.forEach(alertId => {
      const alertRef = doc(db, 'critical_alerts', alertId);
      batch.update(alertRef, {
        acknowledged: true,
        acknowledgedBy,
        acknowledgedAt: new Date().toISOString(),
        updatedAt: serverTimestamp()
      });
    });

    await batch.commit();
    console.log('‚úÖ Multiple alerts acknowledged:', alertIds.length);
  } catch (error) {
    console.error('‚ùå Error acknowledging multiple alerts:', error);
    throw error;
  }
};

// Update alert severity with cascading notification update
export const updateAlertSeverity = async (
  alertId: string,
  newSeverity: CriticalAlert['severity']
): Promise<void> => {
  try {
    const alertRef = doc(db, 'critical_alerts', alertId);
    await updateDoc(alertRef, {
      severity: newSeverity,
      priority: newSeverity,
      updatedAt: serverTimestamp()
    });
    
    console.log(`‚úÖ Alert ${alertId} severity updated to ${newSeverity}`);
  } catch (error) {
    console.error('‚ùå Error updating alert severity:', error);
    throw error;
  }
};

// Enhanced escalation with notification integration
export const escalateAlert = async (
  alertId: string,
  escalationEntry: EscalationEntry
): Promise<void> => {
  try {
    // Get current alert
    const alertQuery = query(
      collection(db, 'critical_alerts'), 
      where('__name__', '==', alertId)
    );
    const alertSnapshot = await getDocs(alertQuery);
    
    if (alertSnapshot.empty) {
      throw new Error('Alert not found');
    }

    const currentAlert = alertSnapshot.docs[0].data() as CriticalAlert;
    const updatedEscalationHistory = currentAlert.escalationHistory
      ? [...currentAlert.escalationHistory, escalationEntry]
      : [escalationEntry];

    const alertRef = doc(db, 'critical_alerts', alertId);
    await updateDoc(alertRef, {
      escalationHistory: updatedEscalationHistory,
      updatedAt: serverTimestamp(),
      severity: 'critical', // Automatically set to critical on escalation
      priority: 'critical'
    });

    // Create escalation notification
    if (currentAlert.userId) {
      await addNotificationWithDuplicateCheck({
        userId: currentAlert.userId,
        title: `üö® Alert Escalated - ${currentAlert.patientName}`,
        body: `Alert escalated: ${escalationEntry.reason}`
      }, {
        metaType: 'alert-escalation',
        role: 'healthcare-provider',
        priority: 'critical',
        data: {
          alertId,
          escalationReason: escalationEntry.reason,
          escalatedBy: escalationEntry.escalatedBy
        }
      });
    }
    
    console.log('‚úÖ Alert escalated:', alertId);
  } catch (error) {
    console.error('‚ùå Error escalating alert:', error);
    throw error;
  }
};

// Enhanced resolve alert with notification cleanup
export const resolveAlert = async (
  alertId: string, 
  resolvedBy: string,
  resolutionNotes?: string
): Promise<void> => {
  try {
    const alertRef = doc(db, 'critical_alerts', alertId);
    await updateDoc(alertRef, {
      resolved: true,
      resolvedBy,
      resolvedAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      resolutionNotes: resolutionNotes || ''
    });
    
    console.log('‚úÖ Alert resolved:', alertId);
  } catch (error) {
    console.error('‚ùå Error resolving alert:', error);
    throw error;
  }
};

// Dismiss alert (alias for resolve)
export const dismissAlert = async (alertId: string, dismissedBy?: string): Promise<void> => {
  return resolveAlert(alertId, dismissedBy || 'system', 'Alert dismissed');
};

// Enhanced alert statistics
export const getAlertsStats = async (businessId: string): Promise<{
  total: number;
  critical: number;
  high: number;
  medium: number;
  low: number;
  unacknowledged: number;
  autoGenerated: number;
  vitals: number;
  medication: number;
  emergency: number;
  resolved: number;
  active: number;
}> => {
  try {
    const alertsRef = collection(db, 'critical_alerts');
    const q = query(alertsRef, where('businessId', '==', businessId));
    const querySnapshot = await getDocs(q);
    
    let total = 0;
    let critical = 0;
    let high = 0;
    let medium = 0;
    let low = 0;
    let unacknowledged = 0;
    let autoGenerated = 0;
    let vitals = 0;
    let medication = 0;
    let emergency = 0;
    let resolved = 0;
    let active = 0;

    querySnapshot.forEach((docSnap) => {
      const alert = docSnap.data() as CriticalAlert;
      total++;
      
      if (alert.severity === 'critical') critical++;
      if (alert.severity === 'high') high++;
      if (alert.severity === 'medium') medium++;
      if (alert.severity === 'low') low++;
      if (!alert.acknowledged) unacknowledged++;
      if (alert.autoGenerated) autoGenerated++;
      if (['vitals', 'auto-escalation'].includes(alert.alertType || '')) vitals++;
      if (alert.alertType === 'medication') medication++;
      if (alert.alertType === 'emergency') emergency++;
      if (alert.resolved) resolved++;
      if (!alert.resolved) active++;
    });

    return { 
      total, critical, high, medium, low, unacknowledged, 
      autoGenerated, vitals, medication, emergency, resolved, active 
    };
  } catch (error) {
    console.error('‚ùå Error getting alerts stats:', error);
    throw error;
  }
};

// Real-time alerts listener with enhanced filtering
export const subscribeToAlerts = (
  callback: (alerts: CriticalAlert[]) => void,
  businessId: string,
  options?: {
    resolved?: boolean;
    acknowledged?: boolean;
    severity?: string;
    limitCount?: number;
  }
): (() => void) => {
  const alertsRef = collection(db, 'critical_alerts');
  let q = query(alertsRef, where('businessId', '==', businessId));
  
  // Apply filters
  if (options?.resolved !== undefined) {
    q = query(q, where('resolved', '==', options.resolved));
  }
  if (options?.acknowledged !== undefined) {
    q = query(q, where('acknowledged', '==', options.acknowledged));
  }
  if (options?.severity) {
    q = query(q, where('severity', '==', options.severity));
  }
  
  // Add ordering and limit
  q = query(q, orderBy('timestamp', 'desc'));
  if (options?.limitCount) {
    q = query(q, limit(options.limitCount));
  }
  
  return onSnapshot(q, (querySnapshot) => {
    const alerts: CriticalAlert[] = [];
    querySnapshot.forEach((doc) => {
      alerts.push({ id: doc.id, ...doc.data() as CriticalAlert });
    });
    callback(alerts);
  }, (error) => {
    console.error('‚ùå Error in alerts subscription:', error);
  });
};

// Sync offline alerts functionality
export const syncOfflineAlerts = async (): Promise<void> => {
  try {
    console.log('üîÑ Syncing offline alerts...');
    // Implementation would read from localforage, sync to Firestore, then clear local storage
    // This is a placeholder for offline functionality
    return Promise.resolve();
  } catch (error) {
    console.error('‚ùå Error syncing offline alerts:', error);
    throw error;
  }
};

// Enhanced alert search functionality
export const searchAlerts = async (
  businessId: string,
  searchTerm: string,
  filters?: {
    severity?: string;
    alertType?: string;
    resolved?: boolean;
    dateRange?: { start: Date; end: Date };
  }
): Promise<CriticalAlert[]> => {
  try {
    const alertsRef = collection(db, 'critical_alerts');
    let q = query(alertsRef, where('businessId', '==', businessId));

    // Apply filters
    if (filters?.severity) {
      q = query(q, where('severity', '==', filters.severity));
    }
    if (filters?.alertType) {
      q = query(q, where('alertType', '==', filters.alertType));
    }
    if (filters?.resolved !== undefined) {
      q = query(q, where('resolved', '==', filters.resolved));
    }
    if (filters?.dateRange) {
      q = query(
        q, 
        where('timestamp', '>=', Timestamp.fromDate(filters.dateRange.start)),
        where('timestamp', '<=', Timestamp.fromDate(filters.dateRange.end))
      );
    }

    const querySnapshot = await getDocs(q);
    const alerts: CriticalAlert[] = [];
    
    querySnapshot.forEach((doc) => {
      const alert = { id: doc.id, ...doc.data() as CriticalAlert };
      
      // Client-side text search
      const searchLower = searchTerm.toLowerCase();
      if (
        alert.patientName?.toLowerCase().includes(searchLower) ||
        alert.message?.toLowerCase().includes(searchLower) ||
        alert.diagnosis?.toLowerCase().includes(searchLower) ||
        alert.ward?.toLowerCase().includes(searchLower)
      ) {
        alerts.push(alert);
      }
    });
    
    return alerts;
  } catch (error) {
    console.error('‚ùå Error searching alerts:', error);
    throw error;
  }
};

export default {
  createCriticalAlert,
  createVitalsAlert,
  getCriticalAlerts,
  getUnacknowledgedAlerts,
  acknowledgeAlert,
  acknowledgeMultipleAlerts,
  updateAlertSeverity,
  escalateAlert,
  resolveAlert,
  dismissAlert,
  getAlertsStats,
  subscribeToAlerts,
  syncOfflineAlerts,
  searchAlerts
};